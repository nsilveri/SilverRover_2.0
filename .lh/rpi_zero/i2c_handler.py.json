{
    "sourceFile": "rpi_zero/i2c_handler.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1768982853627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1768982867644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,9 +175,9 @@\n     server = HTTPServer((\"0.0.0.0\", 8000), RelayHandler)\r\n     threading.Thread(target=server.serve_forever, daemon=True).start()\r\n \r\n # =======================\r\n-# I2C MAIN LOOP (UNICO)\r\n+# I2C MAIN LOOP \r\n # =======================\r\n def i2c_loop(client):\r\n     global REQ_ARRAY_INDEX\r\n     sequence = [MOTOR_UNIT_ADDRESS, SOLAR_UNIT_ADDRESS, POWER_UNIT_ADDRESS]\r\n"
                },
                {
                    "date": 1768983869314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,9 +131,9 @@\n         with state_lock:\r\n             STATE[slave_addr][\"packet\"] = packet\r\n             STATE[slave_addr][\"reg\"] = reg\r\n             STATE[slave_addr][\"dirty\"] = True\r\n-            STATE[slave_addr][\"oneshot\"] = True  # comando momentaneo\r\n+            STATE[slave_addr][\"oneshot\"] = True  \r\n \r\n     except Exception:\r\n         traceback.print_exc()\r\n \r\n@@ -175,9 +175,9 @@\n     server = HTTPServer((\"0.0.0.0\", 8000), RelayHandler)\r\n     threading.Thread(target=server.serve_forever, daemon=True).start()\r\n \r\n # =======================\r\n-# I2C MAIN LOOP \r\n+# I2C MAIN LOOP\r\n # =======================\r\n def i2c_loop(client):\r\n     global REQ_ARRAY_INDEX\r\n     sequence = [MOTOR_UNIT_ADDRESS, SOLAR_UNIT_ADDRESS, POWER_UNIT_ADDRESS]\r\n"
                },
                {
                    "date": 1768983874917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,9 +131,9 @@\n         with state_lock:\r\n             STATE[slave_addr][\"packet\"] = packet\r\n             STATE[slave_addr][\"reg\"] = reg\r\n             STATE[slave_addr][\"dirty\"] = True\r\n-            STATE[slave_addr][\"oneshot\"] = True  \r\n+            STATE[slave_addr][\"oneshot\"] = True\r\n \r\n     except Exception:\r\n         traceback.print_exc()\r\n \r\n"
                }
            ],
            "date": 1768982853627,
            "name": "Commit-0",
            "content": "# pip install paho-mqtt smbus2\r\n\r\nimport time\r\nimport threading\r\nimport struct\r\nimport json\r\nimport logging\r\nimport traceback\r\n\r\nfrom smbus2 import SMBus\r\nimport paho.mqtt.client as mqtt\r\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\r\nfrom urllib.parse import urlparse\r\n\r\n# =======================\r\n# I2C CONFIG\r\n# =======================\r\nI2C_BUS = 1\r\nMAX_CHARS = 32\r\n\r\nMOTOR_UNIT_ADDRESS = 0x45\r\nSOLAR_UNIT_ADDRESS = 0x47\r\nPOWER_UNIT_ADDRESS = 0x49\r\n\r\n# =======================\r\n# MQTT CONFIG\r\n# =======================\r\nMQTT_BROKER = 'localhost'\r\nMQTT_PORT = 1883\r\n\r\nI2C_MAP = {\r\n    'rover/accel':               (MOTOR_UNIT_ADDRESS, 1),\r\n    'rover/steering_all':        (MOTOR_UNIT_ADDRESS, 2),\r\n    'rover/steering_each':       (MOTOR_UNIT_ADDRESS, 5),\r\n    'rover/steering_continuous': (MOTOR_UNIT_ADDRESS, 6),\r\n    'rover/camera':              (SOLAR_UNIT_ADDRESS, 3),\r\n    'rover/camera_continuous':   (SOLAR_UNIT_ADDRESS, 5),\r\n    'rover/panel':               (SOLAR_UNIT_ADDRESS, 4),\r\n}\r\n\r\nMQTT_TOPICS = list(I2C_MAP.keys())\r\n\r\n# =======================\r\n# POWER SUPPLY CONFIG\r\n# =======================\r\nBASE_TOPIC = 'rover/power'\r\n\r\nREQ_ARRAY_TOPICS = [\r\n    \"INA226_1\", \"INA226_2\",\r\n    \"INA3221_CH1\", \"INA3221_CH2\", \"INA3221_CH3\"\r\n]\r\n\r\nREQ_ARRAY = [0x01, 0x02, 0x03, 0x04, 0x05]\r\nREQ_ARRAY_INDEX = 0\r\nPOLL_DELAY = 0.5\r\n\r\n# =======================\r\n# SHARED STATE\r\n# =======================\r\nSTATE = {\r\n    MOTOR_UNIT_ADDRESS: {\"packet\": None, \"reg\": None, \"dirty\": False, \"oneshot\": False},\r\n    SOLAR_UNIT_ADDRESS: {\"packet\": None, \"reg\": None, \"dirty\": False, \"oneshot\": False},\r\n    POWER_UNIT_ADDRESS: {\"packet\": None, \"reg\": None, \"dirty\": False, \"oneshot\": False}\r\n}\r\n\r\nstate_lock = threading.Lock()\r\n\r\n# =======================\r\n# HELPERS\r\n# =======================\r\ndef build_packet(reg, payload_str):\r\n    payload = payload_str.encode('utf-8')\r\n    if len(payload) > MAX_CHARS:\r\n        raise ValueError(\"Payload troppo lungo\")\r\n\r\n    return [reg, len(payload)] + list(payload) + [0x01, 0xFF]\r\n\r\n\r\ndef publish_measurement(client, reg, voltage, current):\r\n    topic = f\"{BASE_TOPIC}/{reg}\"\r\n    payload = {\r\n        \"reg\": reg,\r\n        \"voltage\": round(voltage, 2),\r\n        \"current\": round(current, 2)\r\n    }\r\n    client.publish(topic, json.dumps(payload), qos=0)\r\n    logging.info(\"Published %s -> %s\", topic, payload)\r\n\r\n# =======================\r\n# MQTT CALLBACKS\r\n# =======================\r\ndef on_connect(client, userdata, flags, rc):\r\n    logging.info(\"MQTT connected\")\r\n    for topic in MQTT_TOPICS:\r\n        client.subscribe(topic)\r\n\r\n\r\ndef on_message(client, userdata, msg):\r\n    try:\r\n        payload_txt = msg.payload.decode().strip()\r\n        mapping = I2C_MAP.get(msg.topic)\r\n        if not mapping:\r\n            return\r\n\r\n        slave_addr, reg = mapping\r\n\r\n        # ---- PAYLOAD BUILDING ----\r\n        if msg.topic in ('rover/camera', 'rover/camera_continuous', 'rover/panel'):\r\n            values = [int(x) for x in payload_txt.split(',')]\r\n            values += [0] * (3 - len(values))\r\n            payload_str = f\"{reg},{values[0]},{values[1]},{values[2]},0,0\"\r\n\r\n        elif msg.topic == 'rover/steering_each':\r\n            parts = payload_txt.split(',')\r\n            values = [int(p) if p else 0 for p in parts[:4]]\r\n            values += [0] * (4 - len(values))\r\n            payload_str = f\"{reg},{values[0]},{values[1]},{values[2]},{values[3]},0\"\r\n\r\n        elif msg.topic == 'rover/steering_continuous':\r\n            parts = payload_txt.split(',')\r\n            front = int(parts[0]) if len(parts) > 0 and parts[0] else 0\r\n            rear  = int(parts[1]) if len(parts) > 1 and parts[1] else 0\r\n            payload_str = f\"{reg},{front},{rear},0,0,0\"\r\n\r\n        else:\r\n            value = int(payload_txt.split(',')[0]) if payload_txt else 0\r\n            payload_str = f\"{reg},{value},0,0,0,0\"\r\n\r\n        packet = build_packet(reg, payload_str)\r\n\r\n        with state_lock:\r\n            STATE[slave_addr][\"packet\"] = packet\r\n            STATE[slave_addr][\"reg\"] = reg\r\n            STATE[slave_addr][\"dirty\"] = True\r\n            STATE[slave_addr][\"oneshot\"] = True  # comando momentaneo\r\n\r\n    except Exception:\r\n        traceback.print_exc()\r\n\r\n# =======================\r\n# HTTP RELAY\r\n# =======================\r\nclass RelayHandler(BaseHTTPRequestHandler):\r\n    def do_POST(self):\r\n        parsed = urlparse(self.path)\r\n        if parsed.path != \"/ir_relay\":\r\n            self.send_response(404)\r\n            self.end_headers()\r\n            return\r\n\r\n        length = int(self.headers.get(\"Content-Length\", 0))\r\n        body = self.rfile.read(length).decode().strip().lower()\r\n\r\n        if body not in (\"on\", \"off\"):\r\n            self.send_response(400)\r\n            self.end_headers()\r\n            return\r\n\r\n        reg = 0x07 if body == \"on\" else 0x08\r\n        packet = [0, 1, reg, 0x01, 0xFF]\r\n\r\n        with state_lock:\r\n            STATE[POWER_UNIT_ADDRESS][\"packet\"] = packet\r\n            STATE[POWER_UNIT_ADDRESS][\"reg\"] = 0\r\n            STATE[POWER_UNIT_ADDRESS][\"dirty\"] = True\r\n            STATE[POWER_UNIT_ADDRESS][\"oneshot\"] = True\r\n\r\n        self.send_response(200)\r\n        self.end_headers()\r\n\r\n    def log_message(self, *args):\r\n        pass\r\n\r\ndef start_http():\r\n    server = HTTPServer((\"0.0.0.0\", 8000), RelayHandler)\r\n    threading.Thread(target=server.serve_forever, daemon=True).start()\r\n\r\n# =======================\r\n# I2C MAIN LOOP (UNICO)\r\n# =======================\r\ndef i2c_loop(client):\r\n    global REQ_ARRAY_INDEX\r\n    sequence = [MOTOR_UNIT_ADDRESS, SOLAR_UNIT_ADDRESS, POWER_UNIT_ADDRESS]\r\n\r\n    while True:\r\n        for addr in sequence:\r\n\r\n            # ===== SEND COMMANDS =====\r\n            with state_lock:\r\n                entry = STATE.get(addr, {})\r\n                packet = entry.get(\"packet\")\r\n                reg = entry.get(\"reg\")\r\n                dirty = entry.get(\"dirty\", False)\r\n                oneshot = entry.get(\"oneshot\", False)\r\n\r\n            if packet and reg is not None and dirty:\r\n                try:\r\n                    with SMBus(I2C_BUS) as bus:\r\n                        bus.write_i2c_block_data(addr, reg, packet[1:])\r\n                    with state_lock:\r\n                        STATE[addr][\"dirty\"] = False\r\n                        if oneshot:\r\n                            STATE[addr][\"packet\"] = None\r\n                            STATE[addr][\"reg\"] = None\r\n                            STATE[addr][\"oneshot\"] = False\r\n                except Exception as e:\r\n                    logging.warning(\"I2C write error %02X: %s\", addr, e)\r\n\r\n            # ===== POWER POLLING =====\r\n            if addr == POWER_UNIT_ADDRESS:\r\n                reg = REQ_ARRAY[REQ_ARRAY_INDEX]\r\n                topic = REQ_ARRAY_TOPICS[REQ_ARRAY_INDEX]\r\n\r\n                try:\r\n                    with SMBus(I2C_BUS) as bus:\r\n                        bus.write_i2c_block_data(addr, 0, [reg])\r\n                        time.sleep(0.1)\r\n\r\n                        t0 = time.time()\r\n                        status = None\r\n                        while time.time() - t0 < 0.2:\r\n                            status = bus.read_i2c_block_data(addr, 0, 1)[0]\r\n                            if status == 0xAA:\r\n                                break\r\n                            time.sleep(0.01)\r\n\r\n                        if status == 0xAA:\r\n                            data = bus.read_i2c_block_data(addr, 0, 9)\r\n                            voltage, current = struct.unpack('<ff', bytes(data[1:9]))\r\n                            publish_measurement(client, topic, voltage, current)\r\n\r\n                except Exception as e:\r\n                    logging.warning(\"Power poll error: %s\", e)\r\n\r\n                REQ_ARRAY_INDEX = (REQ_ARRAY_INDEX + 1) % len(REQ_ARRAY)\r\n\r\n            time.sleep(0.02)\r\n\r\n# =======================\r\n# MAIN\r\n# =======================\r\ndef main():\r\n    logging.basicConfig(level=logging.INFO)\r\n\r\n    client = mqtt.Client()\r\n    client.on_connect = on_connect\r\n    client.on_message = on_message\r\n    client.connect(MQTT_BROKER, MQTT_PORT, 60)\r\n    client.loop_start()\r\n\r\n    start_http()\r\n\r\n    threading.Thread(target=i2c_loop, args=(client,), daemon=True).start()\r\n\r\n    while True:\r\n        time.sleep(1)\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"
        }
    ]
}